import Foundation

enum APIError: LocalizedError {
    case invalidURL
    case httpError(Int, String)
    case decodingError(String)
    case unauthorized
    case networkError(String)

    var errorDescription: String? {
        switch self {
        case .invalidURL:
            return "Invalid URL"
        case .httpError(let code, let message):
            return "HTTP \(code): \(message)"
        case .decodingError(let detail):
            return "Decode error: \(detail)"
        case .unauthorized:
            return "Not authenticated"
        case .networkError(let detail):
            return "Network error: \(detail)"
        }
    }
}

@MainActor
final class OpticonAPI: @unchecked Sendable {
    static let shared = OpticonAPI()

    private let baseURL = "https://opticon.heyitsmejosh.com"
    private let session: URLSession
    private let decoder: JSONDecoder

    private init() {
        let config = URLSessionConfiguration.default
        config.httpCookieStorage = HTTPCookieStorage.shared
        config.httpCookieAcceptPolicy = .always
        config.httpShouldSetCookies = true
        config.timeoutIntervalForRequest = 15
        config.timeoutIntervalForResource = 30
        session = URLSession(configuration: config)
        decoder = JSONDecoder()
    }

    // MARK: - Auth

    func login(email: String, password: String) async throws -> User {
        let url = try makeURL("/api/auth", query: ["action": "login"])
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.httpBody = try JSONEncoder().encode(["email": email, "password": password])

        let data = try await perform(request)
        return try decode(User.self, from: data)
    }

    func register(email: String, password: String) async throws -> User {
        let url = try makeURL("/api/auth", query: ["action": "register"])
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.httpBody = try JSONEncoder().encode(["email": email, "password": password])

        let data = try await perform(request)
        return try decode(User.self, from: data)
    }

    func logout() async throws {
        let url = try makeURL("/api/auth", query: ["action": "logout"])
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        _ = try await perform(request)
    }

    func me() async throws -> User {
        let url = try makeURL("/api/auth", query: ["action": "me"])
        let request = URLRequest(url: url)
        let data = try await perform(request)
        return try decode(User.self, from: data)
    }

    // MARK: - Market Data

    func fetchStocks() async throws -> [Stock] {
        let url = try makeURL("/api/stocks")
        let request = URLRequest(url: url)
        let data = try await perform(request)
        return try decode([Stock].self, from: data)
    }

    func fetchPriceHistory(symbol: String, range: String = "1y") async throws -> PriceHistory {
        let url = try makeURL("/api/history", query: [
            "symbol": symbol,
            "range": range
        ])
        let request = URLRequest(url: url)
        let data = try await perform(request)
        return try decode(PriceHistory.self, from: data)
    }

    // MARK: - Portfolio

    func fetchPortfolio() async throws -> Portfolio {
        let url = try makeURL("/api/portfolio", query: ["action": "get"])
        let request = URLRequest(url: url)
        let data = try await perform(request)
        return try decode(Portfolio.self, from: data)
    }

    // MARK: - Watchlist

    func fetchWatchlist() async throws -> [WatchlistItem] {
        let url = try makeURL("/api/watchlist")
        let request = URLRequest(url: url)
        let data = try await perform(request)
        return try decode([WatchlistItem].self, from: data)
    }

    func addToWatchlist(symbol: String) async throws -> WatchlistItem {
        let url = try makeURL("/api/watchlist")
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.httpBody = try JSONEncoder().encode(["symbol": symbol])

        let data = try await perform(request)
        return try decode(WatchlistItem.self, from: data)
    }

    func removeFromWatchlist(symbol: String) async throws {
        let url = try makeURL("/api/watchlist", query: ["symbol": symbol])
        var request = URLRequest(url: url)
        request.httpMethod = "DELETE"
        _ = try await perform(request)
    }

    // MARK: - Alerts

    func fetchAlerts() async throws -> [PriceAlert] {
        let url = try makeURL("/api/alerts")
        let request = URLRequest(url: url)
        let data = try await perform(request)
        return try decode([PriceAlert].self, from: data)
    }

    func createAlert(symbol: String, targetPrice: Double, direction: PriceAlert.Direction) async throws -> PriceAlert {
        let url = try makeURL("/api/alerts")
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")

        let body: [String: Any] = [
            "symbol": symbol,
            "target_price": targetPrice,
            "direction": direction.rawValue
        ]
        request.httpBody = try JSONSerialization.data(withJSONObject: body)

        let data = try await perform(request)
        return try decode(PriceAlert.self, from: data)
    }

    func deleteAlert(id: String) async throws {
        let url = try makeURL("/api/alerts", query: ["id": id])
        var request = URLRequest(url: url)
        request.httpMethod = "DELETE"
        _ = try await perform(request)
    }

    // MARK: - Prediction Markets

    func fetchMarkets(limit: Int = 50, order: String = "volume24hr") async throws -> [PredictionMarket] {
        let url = try makeURL("/api/markets", query: [
            "limit": String(limit),
            "order": order,
            "closed": "false",
            "ascending": "false"
        ])
        let request = URLRequest(url: url)
        let data = try await perform(request)
        return try decode([PredictionMarket].self, from: data)
    }

    // MARK: - Internals

    private func makeURL(_ path: String, query: [String: String] = [:]) throws -> URL {
        var components = URLComponents(string: baseURL + path)
        if !query.isEmpty {
            components?.queryItems = query.map { URLQueryItem(name: $0.key, value: $0.value) }
        }
        guard let url = components?.url else { throw APIError.invalidURL }
        return url
    }

    private func perform(_ request: URLRequest) async throws -> Data {
        let data: Data
        let response: URLResponse
        do {
            (data, response) = try await session.data(for: request)
        } catch let urlError as URLError {
            switch urlError.code {
            case .timedOut:
                throw APIError.networkError("Request timed out")
            case .notConnectedToInternet:
                throw APIError.networkError("No internet connection")
            case .networkConnectionLost:
                throw APIError.networkError("Connection lost")
            default:
                throw APIError.networkError(urlError.localizedDescription)
            }
        }

        guard let http = response as? HTTPURLResponse else {
            throw APIError.httpError(0, "No HTTP response")
        }
        guard (200...299).contains(http.statusCode) else {
            if http.statusCode == 401 { throw APIError.unauthorized }
            let body = String(data: data, encoding: .utf8) ?? "unknown"
            throw APIError.httpError(http.statusCode, body)
        }
        return data
    }

    private func decode<T: Decodable>(_ type: T.Type, from data: Data) throws -> T {
        do {
            return try decoder.decode(type, from: data)
        } catch {
            throw APIError.decodingError(error.localizedDescription)
        }
    }
}

// MARK: - Price History

struct PriceHistory: Codable {
    let history: [DataPoint]

    struct DataPoint: Codable, Identifiable {
        let date: String
        let close: Double
        let volume: Int?

        var id: String { date }

        var parsedDate: Date? {
            let formatter = DateFormatter()
            formatter.dateFormat = "yyyy-MM-dd"
            return formatter.date(from: date)
        }
    }
}
